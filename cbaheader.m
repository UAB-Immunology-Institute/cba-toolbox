function S = cbaheader(F)

% CBAHEADER prepare output info for either TXT or PDF reports
%    S = CBAMFI(A) reads a data structure generated by CBAFCS and
%    returns information used by both the text file report as well as the
%    PDF report.
%
%    Usage:
%
%        S = CBAHEADER(A);
%
% -------------------------------------------------------------------------
%
%    Authors: Alexander F. Rosenberg (afr@uab.edu) and Rodney G. King
%        with John T. Killian, Todd J. Green, J. Akther, M. Emon Hossain,
%        Shihong Qiu, Guang Yang, Troy D. Randall and Frances E. Lund
%
%    University of Alabama at Birmingham
%    Department of Microbiology
%    April 11, 2023
%    Copyright (C) 2023 UAB Research Foundation
%    This software is offered with no guarantees of any kind.
%
%    see: "A high-throughput multiplex array for antigen-specific serology
%    with automated analysis", bioRxiv 2023 April.
%    doi: 10.1101/2023.03.29.534777
%
%    This file (part of the "CBA Toolbox") is free software: you can
%    redistribute it and/or modify it under the terms of the GNU General
%    Public License as published by the Free Software Foundation, version 3
%    of the License.  This file is distributed in the hope that it will be
%    useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%    General Public License for more details.  You should have received a
%    copy of the GNU General Public License along with this program.  If  
%    not, see https://www.gnu.org/licenses/gpl-3.0.en.html.


    % input file, profile
    S.part1 = {...
        'CBAFCS_version'     F.version;...
        'FCS_file'           F.fcsname;...
        'analysis_timestamp' F.analysisdate;...
        'array_config'       F.arrayconf;...
        'profile'            F.profile};

    % flow configuration   
    S.part2 = {...
        'bead_channel', char(F.beadchan);...
        'flow_config',  char(F.flowconf)};
    if ~isnan(F.splitchan)
        S.part2 = [S.part2; {'split_channel', char(F.splitchan)}];
        S.part2 = S.part2([1 3 2], :);
    end

    % bead array configuration
    S.part3 = cell(F.nbeadbin, 2);
    for i = 1:F.nbeadbin
        sz = F.beadconf.size(i);
        splitchan = 0;
        if length(find(F.beadconf.size == sz)) > 1, splitchan = 1; end
        sz = num2str(sz);
        bn = num2str(F.beadconf.bin(i));
        if splitchan == 1
            nm = cellstr(['bead_peak_order_' sz '_' bn]);
            fl = cellstr(F.(['peakorder' sz 'p' bn]));
        else
            nm = cellstr(['bead_peak_order_' num2str(sz)]);
            fl = cellstr(F.(['peakorder' sz]));
        end
        S.part3(i, :) = [nm, fl];
    end

    % parameters actually used
    fn = fieldnames(F.settings);
    S.part4 = cell(length(fn), 2);
    for i = 1:length(fn)
        v = F.settings.(fn{i});
        if isstring(v)
            S.part4(i, :) = [cellstr(fn{i}), cellstr(v)];
        elseif isnumeric(v) && isscalar(v)
            S.part4(i, :) = [cellstr(fn{i}), cellstr(num2str(v))];
        elseif isnumeric(v) && ~isscalar(v)
            v = v(:);
            v = strjoin(strip(cellstr(num2str(v))), ', ');
            S.part4(i, :) = [cellstr(fn{i}), cellstr(['[', v, ']'])];
        end
    end 
    
    % event counts prior to peak detection
    part5 = [{'total_events'}, cellstr(num2str(F.counts.total_events))];
    part5a = cell(F.nbeadsize, 2);
    part5b = cell(F.nbeadsize, 2);
    for i = 1:F.nbeadsize
        part5a(i, :) = [...
            cellstr(['bead_' num2str(i) '_events']),...
            cellstr(num2str(F.counts.bead_size_events(i)))];
        part5b(i, :) = [...
            cellstr(['bead_' num2str(i) '_singlets']),...
            cellstr(num2str(F.counts.bead_size_singlets(i)))];
    end
    part5c = [];
    if ~isnan(F.splitchan)
        B = F.counts.bead_size_bins;
        for i = 1:size(B, 1)
            B.nbins(i) = length(find(B.size == B.size(i)));
        end
        B = B(B.nbins > 1, :);
        part5c = cell(size(B, 1), 2);
        for i = 1:size(B, 1)
            part5c(i, :) = [...
                cellstr(['bead_' num2str(B.size(i)) '_singlets_bin_' ...
                    num2str(B.bin(i))]),...
                cellstr(num2str(B.events(i)))];
        end
    end
    S.part5 = [part5; part5a; part5b; part5c];        
    
return

