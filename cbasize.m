function F = cbasize(F)

% CBASIZE read cba flow file and separate beads into their sizes
%
%    A = CBASIZE(A) reads a data structure generated by CBALOAD and
%    annotates events based on their corresponding bead sizes.  Bead sizes
%    are determined based on identifying densities in forward scatter vs
%    size scatter plots.  This function returns an amended version of the
%    input structure.  If figures were requested (set display flag = 1 in
%    cbaload which sets a field in the input structure) then a forward
%    scatter vs side scatter plot with oval gates is shown.
%
%    Usage:
%
%        A = CBASIZE(A);
%
%    Uses the function "dscatter.m" to render 2-D scatter/density plots
%    Copyright (c) 2016, MathWorks Inc. All rights reserved.
%
%    Requires Matlab Signal Processing Toolbox
%    Requires Matlab Curve Fitting Toolbox
%
% -------------------------------------------------------------------------
%
%    Authors: Alexander F. Rosenberg (afr@uab.edu) and Rodney G. King
%        with John T. Killian, Fen Zhou, Davide Botta, Todd J. Green,
%        Jobaida Akther, M. Emon Hossain, Shihong Qiu, Guang Yang,
%        Troy D. Randall and Frances E. Lund
%
%    University of Alabama at Birmingham
%    Department of Microbiology
%    April 11, 2023
%    Copyright (C) 2024 UAB Research Foundation
%    This software is offered with no guarantees of any kind.
%
%    see: "A high-throughput multiplex array for antigen-specific serology
%    with automated analysis", bioRxiv 2023 April.
%    doi: 10.1101/2023.03.29.534777
%
%    This file (part of the "CBA Toolbox") is free software: you can
%    redistribute it and/or modify it under the terms of the GNU General
%    Public License as published by the Free Software Foundation, version 3
%    of the License.  This file is distributed in the hope that it will be
%    useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%    General Public License for more details.  You should have received a
%    copy of the GNU General Public License along with this program.  If  
%    not, see https://www.gnu.org/licenses/gpl-3.0.en.html.


    % initialize structure for plotting variables
    V = struct;
    
    % forward scatter and side scatter
    fsc = F.event.FSC_H;
    ssc = F.event.SSC_H;
    
    % peak finding settings 
    settings = {...
        F.settings.beadsize_xfsc_range,...
        F.settings.beadsize_yssc_range,...
        F.settings.beadsize_bin_size,...
        F.settings.beadsize_loess_smooth,...
        F.settings.beadsize_min_peak_height,...
        F.settings.beadsize_min_peak_prominence};        
        
    % summary counts
    F.counts.total_events = length(fsc);
    F.counts.bead_size_events = nan(F.nbeadsize, 1);
    
    % augment data structure to annotate events as belonging to bead series
    F.event.size = nan(length(fsc), 1);
    
    % identify peak(s) along FSC
    p = {fsc settings{[1 3:end]}};
    [V.fsc.x, V.fsc.y, lc, ~, V.fsc.gate] = gatechannel(p{:});
        
    % check for expected number of FSC peaks
    if length(lc) ~= F.nbeadsize
        error(...
            ['expecting ' num2str(F.nbeadsize) ' FSC peaks, got ' ...
            num2str(length(lc))]);
    end

    % identify events in each of the FSC+SSC peaks, compute ovals
    for i = 1:F.nbeadsize
        
        % events within particular FSC peak
        s = ssc(...
            fsc > V.fsc.gate(i, 1) & ...
            fsc < V.fsc.gate(i, 2));
        
        % now look for single peak in SSC channel
        p = {s settings{2:end}};
        [V.ssc(i).x, V.ssc(i).y, lc, ~, V.ssc(i).gate] = gatechannel(p{:});
            
        % make sure just one peak
        if length(lc) ~= 1
            error(...
                ['>1 SSC peaks for FSC peak ' num2str(i) ', got' ...
                num2str(length(lc)) ')']);
        end
        
        % centroid of each rectangular gate
        V.gate(i).xc = mean(V.fsc.gate(i, :));
        V.gate(i).yc = mean(V.ssc(i).gate);
        
        % major/minor axes for bound oval
        oscale = F.settings.beadsize_oval_gate_scale;
        V.gate(i).a = oscale * diff(V.fsc.gate(i, :)) / 2;
        V.gate(i).b = oscale * diff(V.ssc(i).gate) / 2;
        
        % find events inside the current oval gate
        V.gate(i).igate = find((...
            ((fsc - V.gate(i).xc).^2 / (V.gate(i).a^2)) + ...
            ((ssc - V.gate(i).yc).^2 / (V.gate(i).b^2))) <= 1);  
        
        % compute coords to plot current  oval gate
        [V.gate(i).x, V.gate(i).y] = oval(...
            V.gate(i).xc, V.gate(i).yc, V.gate(i).a, V.gate(i).b);
        
        % update counts in current gate in main data structure
        F.counts.bead_size_events(i) = length(V.gate(i).igate);
        
        % annotate rows in event table that are in this gate
        F.event.size(V.gate(i).igate) = i;
        
    end
            
    % if render plot
    if F.display == 1

        % pixel dimensions of components
        pw = 390;
        gh = 100;
        left = 60;
        bot = 60;
        top = 10;
        right = 10;
        sp = 20;
        fw = left + pw + sp + gh + right;
        fh = bot + pw + sp + gh + top;
    
        % figure layout
        aloc.main = [left / fw, bot / fh, pw / fw, pw / fh];
        aloc.fsc  = [left / fw, (bot + pw + sp) / fh, pw / fw gh / fh];
        aloc.ssc  = [(left + pw + sp) / fw, bot / fh, gh / fw, pw / fh];
        aloc.num  = [(left + pw + sp) / fw, (bot + pw + sp) / fh, gh / fw, gh / fh];

        % blank axes
        pref = struct(...
            'box', 'off',...
            'xcolor', 'w',...
            'ycolor', 'w',...
            'xtick', [],...
            'ytick', []);      
        
        % colororder for different bead sizes
        co = F.pref.colororder(1:F.nbeadsize, 1);
        
        % plot ranges
        xr = F.settings.beadsize_xfsc_range;
        yr = F.settings.beadsize_yssc_range;
            
        % draw figure
        FIG1 = figure('position', [65 440 fw fh]); 

        % axis with # events per bead size
        subplot('position', aloc.num, 'nextplot', 'add');
        text(.1, .8, 'Events:',...
            'fontname', 'arial',...
            'fontsize', 18);
        text(.1, .5, [num2str(F.counts.total_events) ' (total)'],...
            'fontname', 'arial',...
            'fontsize', 14);
        for i = 1:F.nbeadsize
            text(.1, .3 - ((i - 1) * .2),...
                num2str(F.counts.bead_size_events(i)),...
                'fontname', 'arial',...
                'fontsize', 14,...
                'color', co{i});
        end
        set(gca, pref, 'xlim', [0 1], 'ylim', [0 1]);

        % fsc gate
        subplot('position', aloc.fsc, 'nextplot', 'add');
        plot(V.fsc.x, V.fsc.y, '-',...
            'linewidth', 1.5,...
            'color', [1 1 1] * .3);
        for i = 1:F.nbeadsize
            plot([1 1]' * V.fsc.gate(i, :), [0 1], '-', 'color', co{i});
        end
        set(gca, pref, 'xlim', xr);

        % ssc gates within each fsc peak
        subplot('position', aloc.ssc, 'nextplot', 'add');
        for i = 1:F.nbeadsize
            plot(V.ssc(i).y, V.ssc(i).x, '-',...
                'linewidth', 1.5,...
                'color', co{i});
            plot([0 1], [1 1]' * V.ssc(i).gate, '-',...
                'color', co{i});
        end            
        set(gca, pref, 'ylim', yr);
            
        % main density scatter plot
        subplot('position', aloc.main, 'nextplot', 'add');
        dscatter(fsc, ssc);
        for i = 1:F.nbeadsize
            plot(xr, [1 1]' * V.ssc(i).gate, '-',...
                'color', co{i});
            plot([1 1]' * V.fsc.gate(i, :), yr, '-',...
                'color', co{i});
            plot(V.gate(i).x, V.gate(i).y, '-',...
                'linewidth', 2,...
                'color', co{i});
        end
        set(gca,...
            'tickdir', 'out',...
            'box', 'off',...
            'xlim', xr,...
            'ylim', yr,...
            'linewidth', 1,...
            'fontname', 'arial',...
            'fontsize', 12);        
        xlabel('FSC-H (arcsinh-xform)',...
            'fontname', 'arial',...
            'fontsize', 18);
        ylabel('SSC-H (arcsinh-xform)',...
            'fontname', 'arial',...
            'fontsize', 18);   

        % make figure background white
        set(FIG1, 'inverthardcopy', 'off', 'color', 'w'); 
        
        % add to figure handles
        F.figures(1) = FIG1;

    end    

return
